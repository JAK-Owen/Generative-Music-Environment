<!DOCTYPE html>
<html>
<body>

<!-- <button id='start'> START </button>
<button id='stop'> STOP </button> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.6/Tone.js'></script>
<script type="text/javascript" src="https://unpkg.com/@tonejs/ui@0.0.8/build/tonejs-ui.js"></script>


<tone-content>
      <tone-play-toggle></tone-play-toggle>
   </tone-content>

   <script type="text/javascript">
      document.querySelector("tone-play-toggle").addEventListener("play", (e) => {

         const playing = e.detail;

         if (playing){
            Tone.Transport.start();
         } else {
            Tone.Transport.stop();
         }
      });

   </script>

<script>


////////////////////////////////////////////////////////////////////////
// KEY SELECTOR
////////////////////////////////////////////////////////////////////////

const key = {
  cMinor:      ["c2", "d#2", "g2", "c3", "d#3", "g3"],
  cSharpMinor: ["c#2", "e2", "g#2","c#3", "e3", "g#3"],
  dMinor:      ["d2", "f2", "a2", "d3", "f3", "a3"],
  dSharpMinor: ["d#2", "f#2", "a#2", "d#3", "f#3", "a#3"],
  eMinor:      ["e2", "g2", "b2", "e3", "g3", "b3"],
  fMinor:      ["f2", "g#2", "c2", "c#2", "f3", "g#3", "c3"],
  fSharpMinor: ["f#2", "a2","c#2", "f#3", "a3", "c#3"],
  gMinor:      ["g2", "a#2", "d2", "g3", "a#3", "d3"],
  gSharpMinor: ["g#2", "b2", "d#2", "g#3", "b3", "d#3"],
  aMinor:      ["a2", "c2", "e2", "a3", "c3", "e3"],
  aSharpMinor: ["a#2", "c#2", "e#2", "a#3", "c#3", "e#3"],
  bMinor:      ["b2", "d2", "f#2", "b3", "d3", "f#3"],

};

////////////////////////////////////////////////////////////////////////
// WAVEFORM SELECTOR
////////////////////////////////////////////////////////////////////////

const waveform = {
  sine:     "sine",
  triangle: "triangle",
  square:   "square",
  saw:      "sawtooth",

};

////////////////////////////////////////////////////////////////////////
// DURATION SELECTOR
////////////////////////////////////////////////////////////////////////

const duration = {
  "1" : "1n",
  "2" : "2n",
  "4" : "4n",
  "8" : "8n",
  "16": "16n",
  "32": "32n",
  "64": "64n"

};

////////////////////////////////////////////////////////////////////////
// GLOBAL SELECTORS
////////////////////////////////////////////////////////////////////////

Tone.Transport.bpm.value = 16.25;
const scale = key.dSharpMinor;
const wave = waveform.saw;
const noteDuration = duration[1];


//////////////////////////////////////////////////////
// GLOBAL EFFECTS
//////////////////////////////////////////////////////

const reverb = new Tone.Reverb(10).toDestination();

const delay = new Tone.FeedbackDelay("16n.", 0.9).connect(reverb);

const shortReverb = new Tone.Reverb(7).toDestination();

const shortDelay = new Tone.FeedbackDelay("8n.", 0.4).connect(shortReverb);

//////////////////////////////////////////////////////
// SYNTH INST 1
//////////////////////////////////////////////////////

  const synth1 = new Tone.Synth({

    "volume": -8,
  "oscillator": {
    "type": wave
  },
  "envelope": {
    "attack": 0.8,
    "decay": 20.0,
    "sustain": 0.0,
    "release": 20.0,
  },
  "filterEnvelope": {
    "attack": 0.8,
    "decay": 20.0,
    "sustain": 0.0,
    "release": 20.0,
    "baseFrequency": 300,
    "octaves": 4
  }});

  synth1.connect(delay);

  const pattern1 = scale;

  console.log(key);


var index = 0;

Tone.Transport.scheduleRepeat(time => {
  repeat(time);
}, noteDuration);

function repeat(time) {
  let note = pattern1[Math.floor(Math.random() * pattern1.length)];
  synth1.triggerAttackRelease(note, noteDuration, time);
  synth1.envelope.triggerAttackRelease(noteDuration);
  index++;
}
Tone.Transport.start();


///////////////////////////////////////////////

const synth2 = new Tone.Synth({

  "volume": -10,
"oscillator": {
  "type": wave
},
"envelope": {
  "attack": 0.8,
  "decay": 20.0,
  "sustain": 0.0,
  "release": 20.0,
},
"filterEnvelope": {
  "attack": 0.8,
  "decay": 20.0,
  "sustain": 0.0,
  "release": 20.0,
  "baseFrequency": 300,
  "octaves": 4
}});

synth2.connect(delay);

const pattern2 = scale;


var index = 0;

Tone.Transport.scheduleRepeat(time => {
repeat2(time);
}, noteDuration);

function repeat2(time) {
let note = pattern2[Math.floor(Math.random() * pattern2.length)];
synth2.triggerAttackRelease(note, noteDuration, time);
synth2.envelope.triggerAttackRelease(noteDuration);
index++;
}

///////////////////////////////////////////////

const synth3 = new Tone.Synth({

  "volume": -9,
"oscillator": {
  "type": wave
},
"envelope": {
  "attack": 0.8,
  "decay": 20.0,
  "sustain": 0.0,
  "release": 20.0,
},
"filterEnvelope": {
  "attack": 0.8,
  "decay": 20.0,
  "sustain": 0.0,
  "release": 20.0,
  "baseFrequency": 300,
  "octaves": 4
}});

synth3.connect(delay);

const pattern3 = scale;


var index = 0;

Tone.Transport.scheduleRepeat(time => {
repeat3(time);
}, noteDuration);

function repeat3(time) {
let note = pattern3[Math.floor(Math.random() * pattern3.length)];
synth3.triggerAttackRelease(note, noteDuration, time);
synth3.envelope.triggerAttackRelease(noteDuration);
index++;
}

///////////////////////////////////////////////

const synth4 = new Tone.Synth({

  "volume": -10,
"oscillator": {
  "type": wave
},
"envelope": {
  "attack": 0.8,
  "decay": 20.0,
  "sustain": 0.0,
  "release": 20.0,
},
"filterEnvelope": {
  "attack": 0.8,
  "decay": 20.0,
  "sustain": 0.0,
  "release": 20.0,
  "baseFrequency": 300,
  "octaves": 4
}});

const panner4 = new Tone.Panner(-1).connect(delay);

synth4.connect(panner4);

const pattern4 = scale;


var index = 0;

Tone.Transport.scheduleRepeat(time => {
repeat4(time);
}, noteDuration);

function repeat4(time) {
let note = pattern4[Math.floor(Math.random() * pattern4.length)];
synth4.triggerAttackRelease(note, noteDuration, time);
synth4.envelope.triggerAttackRelease(noteDuration);
index++;
}

///////////////////////////////////////////////

const synth5 = new Tone.Synth({

  "volume": -10,
"oscillator": {
  "type": wave
},
"envelope": {
  "attack": 0.8,
  "decay": 20.0,
  "sustain": 0.0,
  "release": 20.0,
},
"filterEnvelope": {
  "attack": 0.8,
  "decay": 20.0,
  "sustain": 0.0,
  "release": 20.0,
  "baseFrequency": 300,
  "octaves": 4
}});

const panner5 = new Tone.Panner(1).connect(delay);

synth5.connect(panner5);

const pattern5 = scale;


var index = 0;

Tone.Transport.scheduleRepeat(time => {
repeat5(time);
}, noteDuration);

function repeat5(time) {
let note = pattern5[Math.floor(Math.random() * pattern5.length)];
synth5.triggerAttackRelease(note, noteDuration, time);
synth5.envelope.triggerAttackRelease(noteDuration);
index++;
}

//////////////////////////////////////////////////////////////////////
//ARP INST1
//////////////////////////////////////////////////////////////////////

// const arp = new Tone.Synth({
//
//   "volume": 2,
// "oscillator": {
//   "type": wave
// },
// "envelope": {
//   "attack": 0.0,
//   "decay": 0.3,
//   "sustain": 0.0,
//   "release": 0.5,
// },
// "filterEnvelope": {
//   "attack": 0.0,
//   "decay": 0.3,
//   "sustain": 0.0,
//   "release": 0.5,
//   "baseFrequency": 300,
//   "octaves": 4
// }});
//
// const pannerA1 = new Tone.Panner(0.5).connect(shortDelay);
//
// arp.connect(pannerA1);
//
// const arpPattern = scale;
//
//
// var index = 0;
//
// Tone.Transport.scheduleRepeat(time => {
// repeatArp(time);
// }, '4n');
//
// function repeatArp(time) {
// let note = arpPattern[Math.floor(Math.random() * arpPattern.length)];
// arp.triggerAttackRelease(note, '4n', time);
// arp.envelope.triggerAttackRelease("4n");
// index++;
// }
//
// //////////////////////////////////////////////////////////////////////
//
// const arp2 = new Tone.Synth({
//
//   "volume": 2,
// "oscillator": {
//   "type": wave
// },
// "envelope": {
//   "attack": 0.0,
//   "decay": 0.3,
//   "sustain": 0.0,
//   "release": 0.5,
// },
// "filterEnvelope": {
//   "attack": 0.0,
//   "decay": 0.3,
//   "sustain": 0.0,
//   "release": 0.5,
//   "baseFrequency": 300,
//   "octaves": 4
// }});
//
// const pannerA2 = new Tone.Panner(-0.5).connect(shortDelay);
//
// arp2.connect(pannerA2);
//
// const arp2Pattern = scale;
//
//
// var index = 0;
//
// Tone.Transport.scheduleRepeat(time => {
// repeatArp2(time);
// }, '8n.');
//
// function repeatArp2(time) {
// let note = arp2Pattern[Math.floor(Math.random() * arp2Pattern.length)];
// arp2.triggerAttackRelease(note, '8n.', time);
// arp2.envelope.triggerAttackRelease("8n.");
// index++;
// }

//////////////////////////////////////////////////////////////////////

  // document.querySelector('button')?.addEventListener('click', async () => {
  //     await Tone.start()
  // })
  //
  // document.querySelector('button')?.addEventListener('click', async () => {
  //     await Tone.stop()
  // })


// function playStop() {
//
// if (stopped){
//   document.querySelector('button')?.addEventListener('click', async () => {
//       await Tone.start()
//   })}
//
// } else (playing) {
//
//   document.querySelector('button')?.addEventListener('click', async () => {
//       await Tone.stop()
//   })
//
// }




// document.querySelector("tone-play-toggle").addEventListener("play", (e) => {
//
//          const playing = e.detail;
//
//          if (playing){
//             Tone.Transport.start();
//          } else {
//             Tone.Transport.pause();
//          }
//       });




</script>

</body>
</html>
